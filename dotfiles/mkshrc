[ -z "$PS1" ] && return

# detect os
OS=$(uname -s)
if [ -z "$HOSTNAME" ]; then
    HOSTNAME=$(hostname -s)
fi

## some terminal settings
# If this is an xterm set the title to user@host:dir
# if 'dumb', just bail without doing anything further
case $TERM in
    xterm*)
        echo -ne "\033]0;@${HOSTNAME%%.*}\007"
        ;;
    dumb)
        # dont save history if 'dumb'
        unset HISTFILE
        return
        ;;
    *) ;;
esac

## load local env vars if they exist
[ -s $HOME/.mksh_pre ] && . $HOME/.mksh_pre


###############
## functions
###############

_prompt_path() {
    local WD=${PWD/$HOME/~}
    if (( ${#WD} > 20 )); then
        print ${WD%%/*}/.../${WD##*/}
    else 
        print $WD
    fi 
}

_git_eread() { 
    f="$1";
    shift;
    test -r "$f" && read "$@" < "$f"
}

_git_ps1() {
    gitdir=$(git rev-parse --git-dir --is-inside-git-dir --is-bare-repository --is-inside-work-tree --short HEAD 2>/dev/null)
    if [ $? = 0 ]; then
        g=$(print "$gitdir"|head -n1)

        local branch=""
        local status=""
        local step=""
        local total=""
        if [  -d "$g/rebase-merge" ]; then
            _git_eread "$g/rebase-merge/head-name" branch
            _git_eread "$g/rebase-merge/msgnum" step;
            _git_eread "$g/rebase-merge/end" total;
            if [ -f "$g/rebase-merge/interactive" ]; then
                status="|REBASE-i"
            else
                status="|REBASE-m"
            fi
        elif [ -d "$g/rebase-apply" ]; then
            _git_eread "$g/rebase-apply/next" step;
            _git_eread "$g/rebase-apply/last" total;
            if [ -f "$g/rebase-apply/rebasing" ]; then
                _git_eread "$g/rebase-merge/head-name" branch
                status="|REBASE"
            else
                if [ -f "$g/rebase-apply/applying" ]; then
                    status="|AM"
                else
                    status="|AM/REBASE"
                fi
            fi
        elif [ -f "$g/MERGE_HEAD" ]; then
            status="|MERGING"
        elif [ -f "$g/CHERRY_PICK_HEAD" ]; then
            status="|CHERRY-PICKING"
        elif [ -f "$g/REVERT_HEAD" ]; then
            status="|REVERTING"
        elif [ -f "$g/BISECT_LOG" ]; then
            status="|BISECTING"
        fi

        if [ -z "$branch" ]; then
            if [ -h "$g/HEAD" ]; then
                branch="$(git symbolic-ref HEAD 2>/dev/null)"
            else
                local head=""
                if [ -r "$g/HEAD" ]; then
                    _git_eread "$g/HEAD" head
                fi
                branch="${head#ref: }"
                if [ "$head" = "$branch" ]; then
                    branch=$(git describe --tags --exact-match HEAD 2>/dev/null)
                    if [ -z "$branch" ]; then
                        branch="$(git rev-parse --short HEAD)..."
                    fi
                fi
            fi
        fi
        branch=${branch##refs/heads/}

        local extra=""
        if [ -n "$step" ]; then
            extra=" ${step}"
        fi
        if [ -n "$total" ]; then
            extra="$extra/${total}"
        fi

        print "(${branch}${status}${extra})"
        return 0
    fi
    return 1
}

_get_prompt_color() {
    local TXTBLK='\e[0;30m' # Black - Regular
    local TXTRED='\e[0;31m' # Red
    local TXTGRN='\e[0;32m' # Green
    local TXTYLW='\e[0;33m' # Yellow
    local TXTBLU='\e[0;34m' # Blue
    local TXTPUR='\e[0;35m' # Purple
    local TXTCYN='\e[0;36m' # Cyan
    local TXTWHT='\e[0;37m' # White
    local BLDBLK='\e[1;30m' # Black - Bold
    local BLDRED='\e[1;31m' # Red
    local BLDGRN='\e[1;32m' # Green
    local BLDYLW='\e[1;33m' # Yellow
    local BLDBLU='\e[1;34m' # Blue
    local BLDPUR='\e[1;35m' # Purple
    local BLDCYN='\e[1;36m' # Cyan
    local BLDWHT='\e[1;37m' # White
    local UNDBLK='\e[4;30m' # Black - Underline
    local UNDRED='\e[4;31m' # Red
    local UNDGRN='\e[4;32m' # Green
    local UNDYLW='\e[4;33m' # Yellow
    local UNDBLU='\e[4;34m' # Blue
    local UNDPUR='\e[4;35m' # Purple
    local UNDCYN='\e[4;36m' # Cyan
    local UNDWHT='\e[4;37m' # White
    local BAKBLK='\e[40m'   # Black - Background
    local BAKRED='\e[41m'   # Red - Background
    local BAKGRN='\e[42m'   # Green - Background
    local BAKYLW='\e[43m'   # Yellow - Background
    local BAKBLU='\e[44m'   # Blue - Background
    local BAKPUR='\e[45m'   # Purple - Background
    local BAKCYN='\e[46m'   # Cyan - Background
    local BAKWHT='\e[47m'   # White - Background
    local TXTRST='\e[0m'    # Text Reset
    
}


###############
## prompt
###############

PS1=$'\001\r'
if [ -z "$SSH_TTY" ]; then
    PS1=$PS1$'\001\e[0;37m\001'
else
    PS1=$PS1$'\001\e[0;33m\001'
fi
PS1=$PS1$'${USER:=$(id -un)}@${HOSTNAME}\001\e[0m\001:\$(_prompt_path)\$(_git_ps1)'

if (( USER_ID )); then
    PS1="$PS1 $ "
else
    PS1="$PS1 # "
fi


###############
## exported functions
###############

dotfiles_update() {
    $HOME/.myconfigs/scripts/dotfiles_update.sh
}

get_whois_registrant() {
    while read domain; do
        printf "#### ${domain} ####\n"
        whois ${domain} | grep -A6 -E "(Registrant|Registration)"
    done
}

services_lookup() {
    grep -w "${1}" /etc/services
}


###############
## env vars and OS specific stuff
###############

### Load os specific settings
[ -s "$HOME/.profile.d/$OS.sh" ] && . "$HOME/.profile.d/$OS.sh"

## enable colors in grep ##
export GREP_OPTIONS='--color=auto'

## some classic env vars ##
export EDITOR=vim
export VISUAL=vim
export PAGER=less

## some git specific vars ##
export GIT_EDITOR=vim
# pager is set it .gitconfig core.pager
# setting it here overrides that setting (and subsequent args)
#export GIT_PAGER=less

# vim on os x returns a non-zero exit code when called with the short
# path name. fucks up git & friends. Use full path.
if [ "$OS" = "Darwin" ]; then
    export GIT_EDITOR=/usr/bin/vim
    export EDITOR=/usr/bin/vim
    export VISUAL=/usr/bin/vim
fi

## less specific vars ##
# turn off .lesshst file
export LESSHISTFILE="-"
# color highlighting in less
export LESS_TERMCAP_mb=$'\E[01;31m'
export LESS_TERMCAP_md=$'\E[01;31m'
export LESS_TERMCAP_me=$'\E[0m'
export LESS_TERMCAP_se=$'\E[0m'
export LESS_TERMCAP_so=$'\E[01;44;33m'
export LESS_TERMCAP_ue=$'\E[0m'
export LESS_TERMCAP_us=$'\E[01;32m'
export LESS="Ri"

## set the gpg tty for helper apps (like gnupg.vim) ##
export GPG_TTY=$(tty)

# other environment vars
export MOZ_DISABLE_PANGO=1
export FIREFOX_DSP=none
export OOO_FORCE_DESKTOP=gnome
export CLICOLOR=1

# history stuffs
export FCEDIT=vim
export HISTFILE=$HOME/.history

## pull in gpg agent env var
if [ -n "$(type -p gpg-agent)" ] && [ -f "$HOME/.gpg-agent-info" ]; then
    . "$HOME/.gpg-agent-info"
    export GPG_AGENT_INFO
fi

# virtualenvstuff
if [ -e "$(type -p pip)" ] && [ -e "$(type -p virtualenv)" ]; then
    #only run if there is a virtualenv currently activated
    export PIP_REQUIRE_VIRTUALENV=true
    # automatically use the currently active virtualenv
    export PIP_RESPECT_VIRTUALENV=true
    export VIRTUALENV_USE_DISTRIBUTE=true
    export PIP_LOG_FILE=/dev/null
fi



###############
## aliases
###############

alias ls='ls -p'
## special case for getting color on linux.
## why can't it use an env var like bsd ls?? *sigh*
if [ $OS == 'Linux' ]; then alias ls='ls -p --color=auto'; fi

alias l.='ls -d .*'
alias ll='ls -lh'
alias ..='cd ..'

alias myip="curl icanhazip.com"

## load any local overrides at the end
[ -s $HOME/.mkshrc_post ] && . $HOME/.mkshrc_post
unset OS
